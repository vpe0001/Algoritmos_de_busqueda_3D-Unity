\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}

\section{\textit{Navigation Mesh}} \label{referenciaNavMesh}
Una navigation mesh o nav mesh es un conjunto de polígonos, triángulos normalmente, que se usan en los motores gráficos 3D para representar la zona o camino recorrible de un agente. Se crean a partir de los objetos estáticos de una escena, que son los obstáculos, donde no se puede desplazar. El resto de la zona de la escena será zona recorrible por donde nos podemos desplazar.

En relación por ejemplo al A*, sería el equivalente a la matriz que representa el mapa donde se buscará los nodos a explorar.

Está formada por los vértices de los polígonos, y si un punto esta dentro del área que forman entonces ese punto es recorrible. Esto es mas realista en un escenario en tres dimensiones debido a que permite un movimiento menos discretizado, al contrario que las parrillas de casillas que se adecuan más a una representación en dos dimensiones. Y si consideramos los vértices los nodos sucesores, resulta más óptimo computacionalmente, ya que el número de nodos (vértices) a explorar es menor, debido a que no tenemos que tener en cuenta todos los puntos intermedios hasta llegar al vértice, si no unicamente si el vértice es visible o alcanzable desde el nodo actual.

Hemos usado una nav mesh para generar de forma automática el mapa para el A*. En Unity esto se puede hacer de dos formas. En versiones anteriores a la versión 5.6 solo es posible generarlo desde el editor antes del tiempo de ejecución. A partir de la versión 5.6, que permite acceder a las herramientas del editor en tiempo de ejecución, se puede construir a través de NavMeshBuilder, dando mucha más libertad a la hora de crear mapas de forma dinámica o interactiva. Lamentablemnte no se pudo usar la versión 5.6 y la versión más actual que funcionaba en el equipo de desarrollo fue la 5.3.6.

La clase NavMesh de Unity tiene métodos que podemos usar como RayTrace, que lanza un rayo desde un vector a otro y devuelve si son visibles dentro de la NavMesh, es decir, si existe una línea recta entre ellos que los una dentro del camino recorrible. Este método lo hemos usado para decidir si un nodo sucesor es válido o no. Al usarlo encontramos un bug que producía que a veces no se encontrará el camino o bucles infinitos a recorrer las listas. Esto es debido a que puede ocurrir que no devuelva lo mismo dependiendo del orden o sentido en el que se le indiquen los vectores entre los que lanzar el rayo. Por ejemplo RayTrace(vector1, vector2) puede ser visible pero RayTrace(vector2, vector1) no. Para solucionarlo decidimos que para que fuera un sucesor válido debe ser visible en los dos sentidos.
